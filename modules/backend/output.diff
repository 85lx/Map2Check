#include "MemoryTrackPass.h"					#include "MemoryTrackPass.h"
using namespace llvm;						using namespace llvm;
std::string infoFile = "witnessInfo";				std::string infoFile = "witnessInfo";
std::string echoCommand = "echo";				std::string echoCommand = "echo";
// TODO: Work with other types					// TODO: Work with other types
// FIX: It it not current function				// FIX: It it not current function
void MemoryTrackPass::instrumentKlee(NonDetType nonDetType) { <
    switch(nonDetType) {				      <
        case (NonDetType::INTEGER):			      <
        {						      <
            Twine non_det_int("map2check_non_det_int");	      <
            this->caleeFunction->setName(non_det_int);	      <
            break;					      <
        }						      <
        case (NonDetType::CHAR):{			      <
            Twine non_det_char("map2check_non_det_char");     <
            this->caleeFunction->setName(non_det_char);	      <
            break;					      <
        }						      <
         case (NonDetType::POINTER):{			      <
            Twine non_det_pointer("map2check_non_det_pointer" <
            this->caleeFunction->setName(non_det_pointer);    <
            break;					      <
         }						      <
         case (NonDetType::LONG):{			      <
             Twine non_det_long("map2check_non_det_long");    <
            this->caleeFunction->setName(non_det_long);	      <
            break;					      <
        }						      <
        case (NonDetType::USHORT):{			      <
         Twine non_det_ushort("map2check_non_det_ushort");    <
         this->caleeFunction->setName(non_det_ushort);	      <
         break;						      <
        }						      <
         case (NonDetType::ASSUME):{			      <
            Twine assume("map2check_assume");		      <
            this->caleeFunction->setName(assume);	      <
            break;					      <
        }						      <
    }							      <
							      <
							      <
							      <
							      <
}							      <
							      <
void MemoryTrackPass::instrumentKleeInt() {		      <
							      <
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst <
  auto j = this->currentInstruction;			      <
  j++;							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* function_llvm = builder.CreateGlobalStringPtr	      <
      (currentFunction->getName());			      <
							      <
  Value* args[] = {					      <
    this->line_value,					      <
    this->scope_value,					      <
    callInst,						      <
    function_llvm					      <
     };							      <
							      <
  builder.CreateCall(this->map2check_klee_int, args);	      <
}							      <
							      <
void MemoryTrackPass::instrumentKleeChar() {		      <
							      <
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst <
  auto j = this->currentInstruction;			      <
  j++;							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* function_llvm = builder.CreateGlobalStringPtr	      <
      (currentFunction->getName());			      <
  Twine bitcast("map2check_klee_char_cast");		      <
  Value* charCast = CastInst::CreateIntegerCast(callInst, Typ <
  							      <
  Value* args[] = {					      <
    this->line_value,					      <
    this->scope_value,					      <
    // callInst,					      <
    charCast,						      <
    function_llvm					      <
     };							      <
							      <
  builder.CreateCall(this->map2check_klee_char, args);	      <
}							      <
							      <
void MemoryTrackPass::instrumentKleePointer() {		      <
							      <
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst <
  auto j = this->currentInstruction;			      <
  j++;							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* function_llvm = builder.CreateGlobalStringPtr	      <
      (currentFunction->getName());			      <
  Twine bitcast("map2check_klee_pointer_cast");		      <
  Value* charCast = CastInst::CreateIntegerCast(callInst, Typ <
  							      <
  Value* args[] = {					      <
    this->line_value,					      <
    this->scope_value,					      <
    // callInst,					      <
    charCast,						      <
    function_llvm					      <
     };							      <
							      <
  builder.CreateCall(this->map2check_klee_pointer, args);     <
}							      <
							      <
void MemoryTrackPass::instrumentKleeUshort() {		      <
							      <
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst <
  auto j = this->currentInstruction;			      <
  j++;							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* function_llvm = builder.CreateGlobalStringPtr	      <
      (currentFunction->getName());			      <
  Twine bitcast("map2check_klee_ushort_cast");		      <
  Value* charCast = CastInst::CreateIntegerCast(callInst, Typ <
  							      <
  Value* args[] = {					      <
    this->line_value,					      <
    this->scope_value,					      <
    // callInst,					      <
    charCast,						      <
    function_llvm					      <
     };							      <
							      <
  builder.CreateCall(this->map2check_klee_ushort, args);      <
}							      <
							      <
void MemoryTrackPass::instrumentKleeLong() {		      <
							      <
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst <
  auto j = this->currentInstruction;			      <
  j++;							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* function_llvm = builder.CreateGlobalStringPtr	      <
      (currentFunction->getName());			      <
  Twine bitcast("map2check_klee_long_cast");		      <
  Value* charCast = CastInst::CreateIntegerCast(callInst, Typ <
  							      <
  Value* args[] = {					      <
    this->line_value,					      <
    this->scope_value,					      <
    // callInst,					      <
    charCast,						      <
    function_llvm					      <
     };							      <
							      <
  builder.CreateCall(this->map2check_klee_ushort, args);      <
}							      <

void MemoryTrackPass::addWitnessInfo(std::string info) {	void MemoryTrackPass::addWitnessInfo(std::string info) {
  // int result = system(info.c_str());				  // int result = system(info.c_str());
  // If result != 0 means that something gone wrong		  // If result != 0 means that something gone wrong
}								}

// TODO: make dynCast only one time				// TODO: make dynCast only one time
void MemoryTrackPass::instrumentPointer() {			void MemoryTrackPass::instrumentPointer() {
  StoreInst* storeInst = dyn_cast<StoreInst>(&*this->currentI	  StoreInst* storeInst = dyn_cast<StoreInst>(&*this->currentI
  Value* var_address = storeInst->getPointerOperand();		  Value* var_address = storeInst->getPointerOperand();
  Value* receives    = storeInst->getValueOperand();		  Value* receives    = storeInst->getValueOperand();

  auto j = this->currentInstruction;				  auto j = this->currentInstruction;

  Twine bitcast("bitcast");					  Twine bitcast("bitcast");

  Value* varPointerCast = CastInst::CreatePointerCast		  Value* varPointerCast = CastInst::CreatePointerCast
    (var_address,						    (var_address,
     Type::getInt8PtrTy(*this->Ctx),				     Type::getInt8PtrTy(*this->Ctx),
     bitcast,(Instruction*) j);					     bitcast,(Instruction*) j);

  Value* receivesPointerCast = CastInst::CreatePointerCast	  Value* receivesPointerCast = CastInst::CreatePointerCast
    (receives,							    (receives,
     Type::getInt8PtrTy(*this->Ctx),				     Type::getInt8PtrTy(*this->Ctx),
     bitcast,(Instruction*) j);					     bitcast,(Instruction*) j);

  ++j;								  ++j;

  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);
  Value* name_llvm = builder.CreateGlobalStringPtr		  Value* name_llvm = builder.CreateGlobalStringPtr
    (var_address->getName());					    (var_address->getName());

  Value* function_llvm = builder.CreateGlobalStringPtr		  Value* function_llvm = builder.CreateGlobalStringPtr
      (currentFunction->getName());				      (currentFunction->getName());

  Value* args[] = {varPointerCast, receivesPointerCast,		  Value* args[] = {varPointerCast, receivesPointerCast,
           this->scope_value,					           this->scope_value,
           name_llvm,						           name_llvm,
           this->line_value,					           this->line_value,
       function_llvm						       function_llvm
     };								     };

  builder.CreateCall(this->map2check_pointer, args);		  builder.CreateCall(this->map2check_pointer, args);
}								}

void MemoryTrackPass::instrumentPosixMemAllign() {		void MemoryTrackPass::instrumentPosixMemAllign() {
    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn	    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn

    this->caleeFunction = callInst->getCalledFunction();	    this->caleeFunction = callInst->getCalledFunction();

    auto j = this->currentInstruction;				    auto j = this->currentInstruction;
    ++j;							    ++j;

    //Adds map2check_malloc with allocated address and size	    //Adds map2check_malloc with allocated address and size
    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    auto size = callInst->getArgOperand(2);			    auto size = callInst->getArgOperand(2);
    auto pointer = callInst->getOperand(0);			    auto pointer = callInst->getOperand(0);

    Twine bitcast("bitcast");					    Twine bitcast("bitcast");

    Value* varPointerCast = CastInst::CreatePointerCast		    Value* varPointerCast = CastInst::CreatePointerCast
      (pointer,							      (pointer,
       Type::getInt8PtrTy(*this->Ctx),				       Type::getInt8PtrTy(*this->Ctx),
       bitcast,(Instruction*) j);				       bitcast,(Instruction*) j);

    Value* args[] = {varPointerCast, size};			    Value* args[] = {varPointerCast, size};
    builder.CreateCall(map2check_posix, args);			    builder.CreateCall(map2check_posix, args);
}								}

// TODO: make dynCast only one time				// TODO: make dynCast only one time
void MemoryTrackPass::instrumentMalloc() {			void MemoryTrackPass::instrumentMalloc() {
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst	  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst
  auto j = this->currentInstruction;				  auto j = this->currentInstruction;
  ++j;								  ++j;

  //Adds map2check_malloc with allocated address and size	  //Adds map2check_malloc with allocated address and size
  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);
  Value* size = callInst->getArgOperand(0);			  Value* size = callInst->getArgOperand(0);
  Twine bitcast("bitcast");					  Twine bitcast("bitcast");
    if(size == NULL){						    if(size == NULL){

    }								    }
  Value* sizeCast = CastInst::CreateIntegerCast(size, Type::g	  Value* sizeCast = CastInst::CreateIntegerCast(size, Type::g
  Value* args[] = {callInst, size};				  Value* args[] = {callInst, size};
  builder.CreateCall(map2check_malloc, args);			  builder.CreateCall(map2check_malloc, args);
}								}

void MemoryTrackPass::instrumentRealloc() {			void MemoryTrackPass::instrumentRealloc() {
    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn	    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn
    auto j = this->currentInstruction;				    auto j = this->currentInstruction;
    IRBuilder<> freeBuilder((Instruction*)j);			    IRBuilder<> freeBuilder((Instruction*)j);
    auto function_name = this->currentFunction->getName();	    auto function_name = this->currentFunction->getName();
    Value* function_llvm = freeBuilder				    Value* function_llvm = freeBuilder
        .CreateGlobalStringPtr(function_name);			        .CreateGlobalStringPtr(function_name);

    Value* nullValid = ConstantInt				    Value* nullValid = ConstantInt
      ::getSigned(Type::getInt1Ty(*this->Ctx), 1);		      ::getSigned(Type::getInt1Ty(*this->Ctx), 1);


    Value* freeArgs[] = {					    Value* freeArgs[] = {
          callInst->getArgOperand(0),				          callInst->getArgOperand(0),
          this->line_value,					          this->line_value,
          function_llvm,					          function_llvm,
          nullValid						          nullValid
    };								    };

    freeBuilder.CreateCall(map2check_free_resolved_address, f	    freeBuilder.CreateCall(map2check_free_resolved_address, f


    ++j;							    ++j;

    //Adds map2check_malloc with allocated address and size	    //Adds map2check_malloc with allocated address and size
    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    auto size = callInst->getArgOperand(1);			    auto size = callInst->getArgOperand(1);
    Value* args[] = {callInst, size};				    Value* args[] = {callInst, size};
    builder.CreateCall(map2check_malloc, args);			    builder.CreateCall(map2check_malloc, args);
}								}

void MemoryTrackPass::instrumentMemset() {			void MemoryTrackPass::instrumentMemset() {
    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn	    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn
    auto j = this->currentInstruction;				    auto j = this->currentInstruction;

    auto function_name = this->currentFunction->getName();	    auto function_name = this->currentFunction->getName();


    auto size = callInst->getArgOperand(2);			    auto size = callInst->getArgOperand(2);
    auto pointer = callInst->getOperand(0);			    auto pointer = callInst->getOperand(0);

    Twine bitcast("bitcast");					    Twine bitcast("bitcast");

    Value* varPointerCast = CastInst::CreatePointerCast		    Value* varPointerCast = CastInst::CreatePointerCast
      (pointer,							      (pointer,
       Type::getInt8PtrTy(*this->Ctx),				       Type::getInt8PtrTy(*this->Ctx),
       bitcast,(Instruction*) j);				       bitcast,(Instruction*) j);

    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    Value* function_llvm = builder				    Value* function_llvm = builder
        .CreateGlobalStringPtr(function_name);			        .CreateGlobalStringPtr(function_name);
    Value* args[] = {varPointerCast, size};			    Value* args[] = {varPointerCast, size};
    builder.CreateCall(map2check_load, args);			    builder.CreateCall(map2check_load, args);
    Value* args2[] = {this->line_value, function_llvm};		    Value* args2[] = {this->line_value, function_llvm};
    builder.CreateCall(map2check_check_deref, args2);		    builder.CreateCall(map2check_check_deref, args2);
}								}

void MemoryTrackPass::instrumentMemcpy() {			void MemoryTrackPass::instrumentMemcpy() {
    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn	    CallInst* callInst = dyn_cast<CallInst>(&*this->currentIn
    auto j = this->currentInstruction;				    auto j = this->currentInstruction;

    auto function_name = this->currentFunction->getName();	    auto function_name = this->currentFunction->getName();


    auto size = callInst->getArgOperand(2);			    auto size = callInst->getArgOperand(2);
    auto pointer_destiny = callInst->getOperand(0);		    auto pointer_destiny = callInst->getOperand(0);
    auto pointer_origin = callInst->getOperand(1);		    auto pointer_origin = callInst->getOperand(1);

    Twine bitcast("bitcast_memcpy");				    Twine bitcast("bitcast_memcpy");

    Value* varPointerCast = CastInst::CreatePointerCast		    Value* varPointerCast = CastInst::CreatePointerCast
      (pointer_destiny,						      (pointer_destiny,
       Type::getInt8PtrTy(*this->Ctx),				       Type::getInt8PtrTy(*this->Ctx),
       bitcast,(Instruction*) j);				       bitcast,(Instruction*) j);

    Value* sizeCast = CastInst::CreateIntegerCast(size, Type:	    Value* sizeCast = CastInst::CreateIntegerCast(size, Type:


    Value* varPointerCastOrigin = CastInst::CreatePointerCast	    Value* varPointerCastOrigin = CastInst::CreatePointerCast
      (pointer_origin,						      (pointer_origin,
       Type::getInt8PtrTy(*this->Ctx),				       Type::getInt8PtrTy(*this->Ctx),
       bitcast,(Instruction*) j);				       bitcast,(Instruction*) j);

    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    Value* function_llvm = builder				    Value* function_llvm = builder
        .CreateGlobalStringPtr(function_name);			        .CreateGlobalStringPtr(function_name);

    Value* args2[] = {varPointerCastOrigin, sizeCast};		    Value* args2[] = {varPointerCastOrigin, sizeCast};
    builder.CreateCall(map2check_load, args2);			    builder.CreateCall(map2check_load, args2);

    Value* args3[] = {this->line_value, function_llvm};		    Value* args3[] = {this->line_value, function_llvm};
    builder.CreateCall(map2check_check_deref, args3);		    builder.CreateCall(map2check_check_deref, args3);

    Value* args[] = {varPointerCast, sizeCast};			    Value* args[] = {varPointerCast, sizeCast};
    builder.CreateCall(map2check_load, args);			    builder.CreateCall(map2check_load, args);

    builder.CreateCall(map2check_check_deref, args3);		    builder.CreateCall(map2check_check_deref, args3);


}								}

void MemoryTrackPass::instrumentAlloca() {			void MemoryTrackPass::instrumentAlloca() {
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst	  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst
  auto j = this->currentInstruction;				  auto j = this->currentInstruction;
  ++j;								  ++j;

  //Adds map2check_malloc with allocated address and size	  //Adds map2check_malloc with allocated address and size
  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);
  auto size = callInst->getArgOperand(0);			  auto size = callInst->getArgOperand(0);

  Twine non_det("bitcast_map2check_alloca");			  Twine non_det("bitcast_map2check_alloca");
  Value* pointerCast = CastInst					  Value* pointerCast = CastInst
    ::CreatePointerCast(callInst,				    ::CreatePointerCast(callInst,
          Type::getInt8PtrTy(*this->Ctx),			          Type::getInt8PtrTy(*this->Ctx),
          non_det,						          non_det,
          (Instruction*) j);					          (Instruction*) j);
  auto function_name = "";					  auto function_name = "";
    Value* function_llvm = builder				    Value* function_llvm = builder
      .CreateGlobalStringPtr(function_name);			      .CreateGlobalStringPtr(function_name);
  Value* args[] = {function_llvm, pointerCast, size,size};	  Value* args[] = {function_llvm, pointerCast, size,size};
//  Value* args[] = {callInst, size};				//  Value* args[] = {callInst, size};
  builder.CreateCall(map2check_alloca, args);			  builder.CreateCall(map2check_alloca, args);
}								}


/* For the porpose of memory checking calloc is basically	/* For the porpose of memory checking calloc is basically
 * a malloc with 2 args, the first is how many elements		 * a malloc with 2 args, the first is how many elements
 * and the second is the size of the primitive element		 * and the second is the size of the primitive element
*/								*/
void MemoryTrackPass::instrumentCalloc() {			void MemoryTrackPass::instrumentCalloc() {
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst	  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst
  auto j = this->currentInstruction;				  auto j = this->currentInstruction;
  ++j;								  ++j;

  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);
  auto quantityOfElements = callInst->getArgOperand(0);		  auto quantityOfElements = callInst->getArgOperand(0);
  auto sizeOfElements = callInst->getArgOperand(1);		  auto sizeOfElements = callInst->getArgOperand(1);
  Value* args[] = {callInst, quantityOfElements,sizeOfElement	  Value* args[] = {callInst, quantityOfElements,sizeOfElement
  builder.CreateCall(map2check_calloc, args);			  builder.CreateCall(map2check_calloc, args);
}								}

// TODO: make dynCast only one time				// TODO: make dynCast only one time
void MemoryTrackPass::instrumentFree() {			void MemoryTrackPass::instrumentFree() {
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst	  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst
  auto j = this->currentInstruction;				  auto j = this->currentInstruction;
  // ++j;							  // ++j;

  this->caleeFunction = callInst->getCalledFunction();		  this->caleeFunction = callInst->getCalledFunction();
  this->getDebugInfo();						  this->getDebugInfo();
  LoadInst* li;							  LoadInst* li;
  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);

  auto function_name = this->currentFunction->getName();	  auto function_name = this->currentFunction->getName();
    Value* function_llvm = builder				    Value* function_llvm = builder
      .CreateGlobalStringPtr(function_name);			      .CreateGlobalStringPtr(function_name);

  if (this->caleeFunction == NULL) {				  if (this->caleeFunction == NULL) {
    Value* v = callInst->getCalledValue();			    Value* v = callInst->getCalledValue();
    this->caleeFunction = dyn_cast<Function>(v->stripPointerC	    this->caleeFunction = dyn_cast<Function>(v->stripPointerC
    li = dyn_cast<LoadInst>(callInst->getArgOperand(0));	    li = dyn_cast<LoadInst>(callInst->getArgOperand(0));


  }								  }
  else {							  else {
    // Value* addr = callInst->getArgOperand(0)->stripPointer	    // Value* addr = callInst->getArgOperand(0)->stripPointer

    li = dyn_cast<LoadInst>(callInst->				    li = dyn_cast<LoadInst>(callInst->
                      getArgOperand(0)->			                      getArgOperand(0)->
                      stripPointerCasts());			                      stripPointerCasts());


  }								  }
  if(li == NULL) {						  if(li == NULL) {

      Value* nullNotValid = ConstantInt				      Value* nullNotValid = ConstantInt
        ::getSigned(Type::getInt1Ty(*this->Ctx), 0);		        ::getSigned(Type::getInt1Ty(*this->Ctx), 0);


      Value* args[] = {						      Value* args[] = {
            callInst->getArgOperand(0),				            callInst->getArgOperand(0),
            this->line_value,					            this->line_value,
            function_llvm,					            function_llvm,
            nullNotValid					            nullNotValid
      };							      };

      builder.CreateCall(map2check_free_resolved_address, arg	      builder.CreateCall(map2check_free_resolved_address, arg
  }								  }
  else {							  else {

    auto name = li->getPointerOperand()->getName();		    auto name = li->getPointerOperand()->getName();
    Value* name_llvm = builder					    Value* name_llvm = builder
      .CreateGlobalStringPtr(name);				      .CreateGlobalStringPtr(name);

    Twine non_det("bitcast_map2check");				    Twine non_det("bitcast_map2check");
    Value* pointerCast = CastInst				    Value* pointerCast = CastInst
      ::CreatePointerCast(li->getPointerOperand(),		      ::CreatePointerCast(li->getPointerOperand(),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);

    Value* args[] = { name_llvm,				    Value* args[] = { name_llvm,
            pointerCast,					            pointerCast,
            this->scope_value,					            this->scope_value,
            this->line_value,					            this->line_value,
            function_llvm,					            function_llvm,

    };								    };

    builder.CreateCall(map2check_free, args);			    builder.CreateCall(map2check_free, args);
  }								  }

}								}

void MemoryTrackPass::getDebugInfo() {				void MemoryTrackPass::getDebugInfo() {
  unsigned scope_number;					  unsigned scope_number;
  unsigned line_number;						  unsigned line_number;
  DebugLoc location = this->currentInstruction->getDebugLoc()	  DebugLoc location = this->currentInstruction->getDebugLoc()
  if(location) {						  if(location) {
    scope_number = location.getScope()->getMetadataID();	    scope_number = location.getScope()->getMetadataID();
    line_number = location.getLine();				    line_number = location.getLine();

  }								  }
  else {							  else {
    scope_number = 0;						    scope_number = 0;
    line_number  = 0;						    line_number  = 0;
  }								  }


  this->scope_value = ConstantInt				  this->scope_value = ConstantInt
    ::getSigned(Type::getInt32Ty(*this->Ctx), scope_number);	    ::getSigned(Type::getInt32Ty(*this->Ctx), scope_number);
  this->line_value = ConstantInt				  this->line_value = ConstantInt
    ::getSigned(Type::getInt32Ty(*this->Ctx), line_number);	    ::getSigned(Type::getInt32Ty(*this->Ctx), line_number);
}								}

int MemoryTrackPass::getLineNumber() {				int MemoryTrackPass::getLineNumber() {
  unsigned line_number;						  unsigned line_number;
  DebugLoc location = this->currentInstruction->getDebugLoc()	  DebugLoc location = this->currentInstruction->getDebugLoc()
  if(location) {						  if(location) {
    line_number = location.getLine();				    line_number = location.getLine();
  }								  }
  else {							  else {
    line_number  = 0;						    line_number  = 0;
  }								  }
  return line_number;						  return line_number;
}								}

void MemoryTrackPass::instrumentReleaseMemoryOnCurrentInstruc <
  auto j = this->currentInstruction;			      <
  // j--;						      <
  IRBuilder<> builder((Instruction*)j);			      <
  builder.CreateCall(this->map2check_success);		      <
							      <
}							      <
							      <
void MemoryTrackPass::instrumentReleaseMemory() {	      <
  Function::iterator bb = this->currentFunction->end();	      <
  bb--;							      <
							      <
  BasicBlock::iterator i = bb->end();			      <
  i--;							      <
							      <
							      <
  IRBuilder<> builder((Instruction*)i);			      <
							      <
  builder.CreateCall(this->map2check_success);		      <
}							      <

void MemoryTrackPass::instrumentInit() {			void MemoryTrackPass::instrumentInit() {
  Function::iterator bb = this->currentFunction->begin();	  Function::iterator bb = this->currentFunction->begin();
  // // bb--;							  // // bb--;

  BasicBlock::iterator i = bb->begin();				  BasicBlock::iterator i = bb->begin();
							      >
  // // i--;							  // // i--;

  IRBuilder<> builder((Instruction*)i);				  IRBuilder<> builder((Instruction*)i);
  Value* argument = ConstantInt::getSigned(Type::getInt32Ty(* <
  Value* args[] = {argument};				      <
  builder.CreateCall(this->map2check_init, args);	      <
							      <
  Module* currentModule = this->currentFunction->getParent();	  Module* currentModule = this->currentFunction->getParent();

  std::vector<GlobalVariable*> globals;				  std::vector<GlobalVariable*> globals;
  for(auto globalVar = currentModule->global_begin();		  for(auto globalVar = currentModule->global_begin();
           globalVar != currentModule->global_end();		           globalVar != currentModule->global_end();
           globalVar++) {					           globalVar++) {

      GlobalVariable* variable = dyn_cast<GlobalVariable>(&*g	      GlobalVariable* variable = dyn_cast<GlobalVariable>(&*g
      globals.push_back(variable);				      globals.push_back(variable);
  }								  }
    for(int pos = 0; pos < globals.size(); pos++) {		    for(int pos = 0; pos < globals.size(); pos++) {
        GlobalVariable* variable = globals[pos];		        GlobalVariable* variable = globals[pos];
//        errs () << "VAR: " << variable->getName() << "\n";	//        errs () << "VAR: " << variable->getName() << "\n";
        const DataLayout dataLayout = currentModule->getDataL	        const DataLayout dataLayout = currentModule->getDataL
        auto type = variable->getType()->getPointerElementTyp	        auto type = variable->getType()->getPointerElementTyp
        unsigned typeSize = dataLayout.getTypeSizeInBits(type	        unsigned typeSize = dataLayout.getTypeSizeInBits(type
        unsigned primitiveSize = 0;				        unsigned primitiveSize = 0;

        if(type->isArrayTy()) {					        if(type->isArrayTy()) {
            type = type->getArrayElementType();			            type = type->getArrayElementType();
        }							        }

        if(type->isVectorTy()) {				        if(type->isVectorTy()) {
            type = type->getVectorElementType();		            type = type->getVectorElementType();
        }							        }

        primitiveSize = dataLayout.getTypeSizeInBits(type)/8;	        primitiveSize = dataLayout.getTypeSizeInBits(type)/8;

        Value* name_llvm = builder.CreateGlobalStringPtr(vari	        Value* name_llvm = builder.CreateGlobalStringPtr(vari

        ConstantInt* typeSizeValue = ConstantInt::getSigned(T	        ConstantInt* typeSizeValue = ConstantInt::getSigned(T
        ConstantInt* primitiveSizeValue = ConstantInt::getSig	        ConstantInt* primitiveSizeValue = ConstantInt::getSig


        Twine non_det("bitcast_map2check");			        Twine non_det("bitcast_map2check");
        Value* pointerCast = CastInst::CreatePointerCast(vari	        Value* pointerCast = CastInst::CreatePointerCast(vari

        Value* args[] = {name_llvm, pointerCast, typeSizeValu	        Value* args[] = {name_llvm, pointerCast, typeSizeValu
        builder.CreateCall(map2check_alloca, args);		        builder.CreateCall(map2check_alloca, args);
    }								    }

}								}

// TODO: use hash table instead of nested "if's"		// TODO: use hash table instead of nested "if's"
void MemoryTrackPass::switchCallInstruction() {			void MemoryTrackPass::switchCallInstruction() {
  // TODO: Resolve SVCOMP ISSUE				      |	  // TODO: Resolve SVCOMP ISSUE  
  if ((this->caleeFunction->getName() == "__VERIFIER_nondet_i |	  if (this->caleeFunction->getName() == "free") {
    this->instrumentKlee(NonDetType::INTEGER);		      <
    this->instrumentKleeInt();				      <
  }							      <
  // TODO: FIX this hack				      <
  else if ((this->caleeFunction->getName() == "map2check_non_ <
      this->instrumentKleeInt();			      <
  }							      <
  else if ((this->caleeFunction->getName() == "__VERIFIER_non <
    this->instrumentKlee(NonDetType::CHAR);		      <
    this->instrumentKleeChar();				      <
  }							      <
  else if ((this->caleeFunction->getName() == "map2check_non_ <
    this->instrumentKleeChar();				      <
  }							      <
  else if ((this->caleeFunction->getName() == "__VERIFIER_non <
    this->instrumentKlee(NonDetType::POINTER);		      <
    this->instrumentKleePointer();			      <
  }							      <
  else if ((this->caleeFunction->getName() == "map2check_non_ <
    this->instrumentKleePointer();			      <
  }							      <
  else if ((this->caleeFunction->getName() == "__VERIFIER_non <
    this->instrumentKlee(NonDetType::LONG);		      <
    this->instrumentKleeLong();				      <
  }							      <
  else if ((this->caleeFunction->getName() == "map2check_non_ <
    this->instrumentKleeLong();				      <
  }							      <
  else if ((this->caleeFunction->getName() == "__VERIFIER_ass <
    this->instrumentKlee(NonDetType::ASSUME);		      <
//    this->instrumentKleePointer();			      <
  }							      <
  else if ((this->caleeFunction->getName() == "__VERIFIER_non <
    this->instrumentKlee(NonDetType::USHORT);		      <
   this->instrumentKleeUshort();			      <
  }							      <
  else if ((this->caleeFunction->getName() == "map2check_non_ <
       this->instrumentKleeUshort();			      <
  }							      <
							      <
  else if ((this->caleeFunction->getName() == "map2check_assu <
//      this->instrumentKleePointer();			      <
  }							      <
   else if (this->caleeFunction->getName() == "exit") {	      <
							      <
    this->instrumentReleaseMemoryOnCurrentInstruction();      <
  }							      <
   else if (this->caleeFunction->getName() == "abort") {      <
							      <
    this->instrumentReleaseMemoryOnCurrentInstruction();      <
  }							      <
  else if (this->caleeFunction->getName() == this->target_fun <
       && this->isTrackingFunction) {			      <
    this->instrumentTargetFunction();			      <
  }							      <
  else if(this->isTrackingFunction) {			      <
    return;						      <
  }							      <
  else if (this->caleeFunction->getName() == "free") {	      <
    this->instrumentFree();					    this->instrumentFree();
  }								  }
  else if (this->caleeFunction->getName() == "cfree") {		  else if (this->caleeFunction->getName() == "cfree") {
    this->instrumentFree();					    this->instrumentFree();
  }								  }
  else if (this->caleeFunction->getName() == "posix_memalign"	  else if (this->caleeFunction->getName() == "posix_memalign"
    this->instrumentPosixMemAllign();				    this->instrumentPosixMemAllign();
  }								  }
  else if (this->caleeFunction->getName() == "realloc") {	  else if (this->caleeFunction->getName() == "realloc") {
    this->instrumentRealloc();					    this->instrumentRealloc();
  }								  }
  else if (this->caleeFunction->getName() == "memset") {	  else if (this->caleeFunction->getName() == "memset") {
    this->instrumentMemset();					    this->instrumentMemset();
  }								  }
  else if (this->caleeFunction->getName() == "memcpy") {	  else if (this->caleeFunction->getName() == "memcpy") {
    this->instrumentMemcpy();					    this->instrumentMemcpy();
  }								  }
  else if (this->caleeFunction->getName() == "malloc") {	  else if (this->caleeFunction->getName() == "malloc") {
    this->instrumentMalloc();					    this->instrumentMalloc();
  }								  }
  else if (this->caleeFunction->getName() == "valloc") {	  else if (this->caleeFunction->getName() == "valloc") {
    this->instrumentMalloc();					    this->instrumentMalloc();
  }								  }
  else if (this->caleeFunction->getName() == "alloca") {	  else if (this->caleeFunction->getName() == "alloca") {
    this->instrumentAlloca();					    this->instrumentAlloca();
  }								  }
  else if (this->caleeFunction->getName() == "calloc") {	  else if (this->caleeFunction->getName() == "calloc") {
    this->instrumentCalloc();					    this->instrumentCalloc();
  }								  }
    								    
}								}

void MemoryTrackPass::instrumentTargetFunction() {	      <
  auto j = this->currentInstruction;			      <
							      <
  IRBuilder<> builder((Instruction*)j);			      <
  Value* name_llvm = builder.CreateGlobalStringPtr	      <
    (this->target_function);				      <
							      <
  Value* args[] = {name_llvm,				      <
           this->scope_value,				      <
           this->line_value };				      <
							      <
  builder.CreateCall(map2check_target_function,		      <
             args);					      <
}							      <

void MemoryTrackPass::instrumentFunctionAddress() {		void MemoryTrackPass::instrumentFunctionAddress() {
    if(!this->mainFunctionInitialized) {			    if(!this->mainFunctionInitialized) {
        this->functionsValues.push_back(this->currentFunction	        this->functionsValues.push_back(this->currentFunction
        return;							        return;
    }								    }

    Function::iterator bb = this->mainFunction->begin();	    Function::iterator bb = this->mainFunction->begin();
    // // bb--;							    // // bb--;

    BasicBlock::iterator i = bb->begin();			    BasicBlock::iterator i = bb->begin();
    i++;							    i++;


    IRBuilder<> builder((Instruction*)i);			    IRBuilder<> builder((Instruction*)i);
    for(int iterator = 0; iterator < this->functionsValues.si	    for(int iterator = 0; iterator < this->functionsValues.si
        Value* name_llvm = builder.CreateGlobalStringPtr	        Value* name_llvm = builder.CreateGlobalStringPtr
          (this->functionsValues[iterator]->getName());		          (this->functionsValues[iterator]->getName());

        Twine non_det("bitcast_map2check");			        Twine non_det("bitcast_map2check");
        Value* pointerCast = CastInst				        Value* pointerCast = CastInst
          ::CreatePointerCast(this->functionsValues[iterator]	          ::CreatePointerCast(this->functionsValues[iterator]
                Type::getInt8PtrTy(*this->Ctx),			                Type::getInt8PtrTy(*this->Ctx),
                non_det,					                non_det,
                (Instruction*) i);				                (Instruction*) i);

        Value* instrumentationArgs[] = {name_llvm, pointerCas	        Value* instrumentationArgs[] = {name_llvm, pointerCas
        builder.CreateCall(map2check_function, instrumentatio	        builder.CreateCall(map2check_function, instrumentatio

    }								    }

    this->functionsValues.clear();				    this->functionsValues.clear();
}								}

void MemoryTrackPass::instrumentAllocation() {			void MemoryTrackPass::instrumentAllocation() {
  AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->curre	  AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->curre


  auto j = this->currentInstruction;				  auto j = this->currentInstruction;
  j++;								  j++;

  Module* M = this->currentFunction->getParent();		  Module* M = this->currentFunction->getParent();
  const DataLayout dataLayout = M->getDataLayout();		  const DataLayout dataLayout = M->getDataLayout();


  auto type = allocaInst->getType()->getPointerElementType();	  auto type = allocaInst->getType()->getPointerElementType();

  unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;	  unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;

  unsigned primitiveSize = 0;					  unsigned primitiveSize = 0;

  if(type->isArrayTy()) {					  if(type->isArrayTy()) {

      type = type->getArrayElementType();			      type = type->getArrayElementType();
  }								  }



  if(type->isVectorTy()) {					  if(type->isVectorTy()) {
      type = type->getVectorElementType();			      type = type->getVectorElementType();
  }								  }

  primitiveSize = dataLayout.getTypeSizeInBits(type)/8;		  primitiveSize = dataLayout.getTypeSizeInBits(type)/8;
  IRBuilder<> builder((Instruction*)j);				  IRBuilder<> builder((Instruction*)j);
  Value* name_llvm = builder.CreateGlobalStringPtr		  Value* name_llvm = builder.CreateGlobalStringPtr
    (allocaInst->getName());					    (allocaInst->getName());

  ConstantInt* typeSizeValue = ConstantInt::getSigned(Type::g	  ConstantInt* typeSizeValue = ConstantInt::getSigned(Type::g
  ConstantInt* primitiveSizeValue = ConstantInt::getSigned(Ty	  ConstantInt* primitiveSizeValue = ConstantInt::getSigned(Ty


  Twine non_det("bitcast_map2check");				  Twine non_det("bitcast_map2check");
  Value* pointerCast = CastInst					  Value* pointerCast = CastInst
    ::CreatePointerCast(allocaInst,				    ::CreatePointerCast(allocaInst,
          Type::getInt8PtrTy(*this->Ctx),			          Type::getInt8PtrTy(*this->Ctx),
          non_det,						          non_det,
          (Instruction*) j);					          (Instruction*) j);

  Value* args[] = {name_llvm, pointerCast, typeSizeValue, pri	  Value* args[] = {name_llvm, pointerCast, typeSizeValue, pri
  builder.CreateCall(map2check_alloca, args);			  builder.CreateCall(map2check_alloca, args);
}								}

// TODO: make dynCast only one time				// TODO: make dynCast only one time
void MemoryTrackPass::runOnCallInstruction() {			void MemoryTrackPass::runOnCallInstruction() {
  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst	  CallInst* callInst = dyn_cast<CallInst>(&*this->currentInst
  this->caleeFunction = callInst->getCalledFunction();		  this->caleeFunction = callInst->getCalledFunction();

  if (this->caleeFunction == NULL) {				  if (this->caleeFunction == NULL) {
    Value* v = callInst->getCalledValue();			    Value* v = callInst->getCalledValue();
    this->caleeFunction = dyn_cast<Function>(v->stripPointerC	    this->caleeFunction = dyn_cast<Function>(v->stripPointerC

    if(this->caleeFunction != NULL) {				    if(this->caleeFunction != NULL) {
      this->switchCallInstruction();				      this->switchCallInstruction();
    }								    }
  }								  }
  else {							  else {
    this->switchCallInstruction();				    this->switchCallInstruction();
  }								  }

   this->caleeFunction = NULL;					   this->caleeFunction = NULL;
}								}

// TODO: make dynCast only one time				// TODO: make dynCast only one time
void MemoryTrackPass::runOnStoreInstruction() {			void MemoryTrackPass::runOnStoreInstruction() {
  StoreInst* storeInst = dyn_cast<StoreInst>(&*this->currentI	  StoreInst* storeInst = dyn_cast<StoreInst>(&*this->currentI
   if(storeInst->getValueOperand()->getType()->isPointerTy())	   if(storeInst->getValueOperand()->getType()->isPointerTy())
     this->instrumentPointer();					     this->instrumentPointer();


   }								   }

   Value* var_address = storeInst->getPointerOperand();		   Value* var_address = storeInst->getPointerOperand();
   Value* receives    = storeInst->getValueOperand();		   Value* receives    = storeInst->getValueOperand();


   Module* M = this->currentFunction->getParent();		   Module* M = this->currentFunction->getParent();
   const DataLayout dataLayout = M->getDataLayout();		   const DataLayout dataLayout = M->getDataLayout();

   auto type = receives->getType();				   auto type = receives->getType();
   unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;	   unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;
   ConstantInt* typeSizeValue = ConstantInt::getSigned(Type::	   ConstantInt* typeSizeValue = ConstantInt::getSigned(Type::

   auto j = this->currentInstruction;				   auto j = this->currentInstruction;
//    j--;							//    j--;

   Twine non_det("bitcast_map2check_store");			   Twine non_det("bitcast_map2check_store");
   Value* pointerCast = CastInst				   Value* pointerCast = CastInst
     ::CreatePointerCast(var_address,				     ::CreatePointerCast(var_address,
           Type::getInt8PtrTy(*this->Ctx),			           Type::getInt8PtrTy(*this->Ctx),
           non_det,						           non_det,
           (Instruction*) j);					           (Instruction*) j);
//    j++;							//    j++;
   IRBuilder<> builder((Instruction*)j);			   IRBuilder<> builder((Instruction*)j);
   Value* args[] = {pointerCast, typeSizeValue};		   Value* args[] = {pointerCast, typeSizeValue};
   builder.CreateCall(map2check_load, args);			   builder.CreateCall(map2check_load, args);

   Value* function_name_llvm = builder.CreateGlobalStringPtr	   Value* function_name_llvm = builder.CreateGlobalStringPtr
     (this->currentFunction->getName());			     (this->currentFunction->getName());
   Value* args2[] = {this->line_value, function_name_llvm};	   Value* args2[] = {this->line_value, function_name_llvm};
   builder.CreateCall(map2check_check_deref, args2);		   builder.CreateCall(map2check_check_deref, args2);

}								}

void MemoryTrackPass::instrumentNotStaticArrayAlloca() {	void MemoryTrackPass::instrumentNotStaticArrayAlloca() {
    AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->cur	    AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->cur
    Value* v = allocaInst->getArraySize();			    Value* v = allocaInst->getArraySize();
//    Value* v = allocaInst->getOperand(0);			//    Value* v = allocaInst->getOperand(0);

    auto j = this->currentInstruction;				    auto j = this->currentInstruction;
    j++;							    j++;

    Module* M = this->currentFunction->getParent();		    Module* M = this->currentFunction->getParent();
    const DataLayout dataLayout = M->getDataLayout();		    const DataLayout dataLayout = M->getDataLayout();

    auto type = allocaInst->getType()->getPointerElementType(	    auto type = allocaInst->getType()->getPointerElementType(
    unsigned primitiveSize = 0;					    unsigned primitiveSize = 0;
//    type->get							//    type->get

    primitiveSize = dataLayout.getTypeSizeInBits(type)/8;	    primitiveSize = dataLayout.getTypeSizeInBits(type)/8;
    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    Value* name_llvm = builder.CreateGlobalStringPtr		    Value* name_llvm = builder.CreateGlobalStringPtr
      (allocaInst->getName());					      (allocaInst->getName());


    ConstantInt* primitiveSizeValue = ConstantInt::getSigned(	    ConstantInt* primitiveSizeValue = ConstantInt::getSigned(

    Twine non_det("bitcast_map2check");				    Twine non_det("bitcast_map2check");
    Value* pointerCast = CastInst				    Value* pointerCast = CastInst
      ::CreatePointerCast(allocaInst,				      ::CreatePointerCast(allocaInst,
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);

    Value* sizeCast = CastInst					    Value* sizeCast = CastInst
      ::CreateIntegerCast(v,					      ::CreateIntegerCast(v,
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            true,						            true,
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);

    Value* args[] = {name_llvm, pointerCast, sizeCast, primit	    Value* args[] = {name_llvm, pointerCast, sizeCast, primit
    builder.CreateCall(map2check_non_static_alloca, args);	    builder.CreateCall(map2check_non_static_alloca, args);
}								}

void  MemoryTrackPass::instrumentArrayAlloca() {		void  MemoryTrackPass::instrumentArrayAlloca() {

    AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->cur	    AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->cur
    Value* v = allocaInst->getArraySize();			    Value* v = allocaInst->getArraySize();
//    Value* v = allocaInst->getOperand(0);			//    Value* v = allocaInst->getOperand(0);

    auto j = this->currentInstruction;				    auto j = this->currentInstruction;
    j++;							    j++;

    Module* M = this->currentFunction->getParent();		    Module* M = this->currentFunction->getParent();
    const DataLayout dataLayout = M->getDataLayout();		    const DataLayout dataLayout = M->getDataLayout();

    auto type = v->getType();					    auto type = v->getType();
    unsigned primitiveSize = 0;					    unsigned primitiveSize = 0;


    primitiveSize = dataLayout.getTypeSizeInBits(type)/8;	    primitiveSize = dataLayout.getTypeSizeInBits(type)/8;
    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    Value* name_llvm = builder.CreateGlobalStringPtr		    Value* name_llvm = builder.CreateGlobalStringPtr
      (allocaInst->getName());					      (allocaInst->getName());


    ConstantInt* primitiveSizeValue = ConstantInt::getSigned(	    ConstantInt* primitiveSizeValue = ConstantInt::getSigned(

    Twine non_det("bitcast_map2check");				    Twine non_det("bitcast_map2check");
    Value* pointerCast = CastInst				    Value* pointerCast = CastInst
      ::CreatePointerCast(allocaInst,				      ::CreatePointerCast(allocaInst,
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);

    Value* sizeCast = CastInst					    Value* sizeCast = CastInst
      ::CreateIntegerCast(v,					      ::CreateIntegerCast(v,
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            true,						            true,
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);


    Value* args[] = {name_llvm, pointerCast, sizeCast, primit	    Value* args[] = {name_llvm, pointerCast, sizeCast, primit
    builder.CreateCall(map2check_alloca, args);			    builder.CreateCall(map2check_alloca, args);
}								}

void MemoryTrackPass::runOnAllocaInstruction() {		void MemoryTrackPass::runOnAllocaInstruction() {
  AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->curre	  AllocaInst* allocaInst = dyn_cast<AllocaInst>(&*this->curre

  if(allocaInst->isArrayAllocation()) {				  if(allocaInst->isArrayAllocation()) {
      if(allocaInst->isStaticAlloca()) {			      if(allocaInst->isStaticAlloca()) {

           this->instrumentArrayAlloca();			           this->instrumentArrayAlloca();
      } else {							      } else {
          this->instrumentNotStaticArrayAlloca();		          this->instrumentNotStaticArrayAlloca();
      }								      }

  }								  }
  else {							  else {
    this->instrumentAllocation();				    this->instrumentAllocation();
  }								  }


}								}


void MemoryTrackPass::runOnLoadInstruction() {			void MemoryTrackPass::runOnLoadInstruction() {
    LoadInst* loadInst = dyn_cast<LoadInst>(&*this->currentIn	    LoadInst* loadInst = dyn_cast<LoadInst>(&*this->currentIn

    Value* v = loadInst->getPointerOperand()->stripPointerCas	    Value* v = loadInst->getPointerOperand()->stripPointerCas

    Module* M = this->currentFunction->getParent();		    Module* M = this->currentFunction->getParent();
    const DataLayout dataLayout = M->getDataLayout();		    const DataLayout dataLayout = M->getDataLayout();

    auto type = loadInst->getPointerOperand()->getType()->get	    auto type = loadInst->getPointerOperand()->getType()->get
    unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;	    unsigned typeSize = dataLayout.getTypeSizeInBits(type)/8;
    ConstantInt* typeSizeValue = ConstantInt::getSigned(Type:	    ConstantInt* typeSizeValue = ConstantInt::getSigned(Type:

    auto j = this->currentInstruction;				    auto j = this->currentInstruction;
//    j--;							//    j--;

    Twine non_det("bitcast_map2check");				    Twine non_det("bitcast_map2check");
    Value* pointerCast = CastInst				    Value* pointerCast = CastInst
      ::CreatePointerCast(v,					      ::CreatePointerCast(v,
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            non_det,						            non_det,
            (Instruction*) j);					            (Instruction*) j);
//    j++;							//    j++;
    IRBuilder<> builder((Instruction*)j);			    IRBuilder<> builder((Instruction*)j);
    Value* args[] = {pointerCast, typeSizeValue};		    Value* args[] = {pointerCast, typeSizeValue};
    builder.CreateCall(map2check_load, args);			    builder.CreateCall(map2check_load, args);

    Value* function_name_llvm = builder.CreateGlobalStringPtr	    Value* function_name_llvm = builder.CreateGlobalStringPtr
      (this->currentFunction->getName());			      (this->currentFunction->getName());
    Value* args2[] = {this->line_value, function_name_llvm};	    Value* args2[] = {this->line_value, function_name_llvm};
    builder.CreateCall(map2check_check_deref, args2);		    builder.CreateCall(map2check_check_deref, args2);

}								}

void MemoryTrackPass::prepareMap2CheckInstructions() {		void MemoryTrackPass::prepareMap2CheckInstructions() {
  Function& F = *this->currentFunction;				  Function& F = *this->currentFunction;

  this->map2check_target_function = F.getParent()->	      <
    getOrInsertFunction("map2check_target_function",	      <
            Type::getVoidTy(*this->Ctx),		      <
            Type::getInt8PtrTy(*this->Ctx),		      <
            Type::getInt32Ty(*this->Ctx),		      <
            Type::getInt32Ty(*this->Ctx),		      <
            NULL);					      <
							      <
  this->map2check_load = F.getParent()->			  this->map2check_load = F.getParent()->
    getOrInsertFunction("map2check_load",			    getOrInsertFunction("map2check_load",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            NULL);						            NULL);

   this->map2check_init = F.getParent()->		      <
    getOrInsertFunction("map2check_init",		      <
            Type::getVoidTy(*this->Ctx),		      <
            Type::getInt32Ty(*this->Ctx),		      <
            NULL);					      <

   this->map2check_free_resolved_address = F.getParent()->	   this->map2check_free_resolved_address = F.getParent()->
    getOrInsertFunction("map2check_free_resolved_address",	    getOrInsertFunction("map2check_free_resolved_address",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt1Ty(*this->Ctx),			            Type::getInt1Ty(*this->Ctx),
            NULL);						            NULL);

    this->map2check_klee_int = F.getParent()->		      <
      getOrInsertFunction("map2check_klee_int",		      <
            Type::getVoidTy(*this->Ctx),		      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
            Type::getInt8PtrTy(*this->Ctx),		      <
            NULL);					      <
							      <
    this->map2check_klee_pointer = F.getParent()->	      <
      getOrInsertFunction("map2check_klee_pointer",	      <
            Type::getVoidTy(*this->Ctx),		      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
            Type::getInt8PtrTy(*this->Ctx),		      <
            NULL);					      <
							      <
    this->map2check_klee_ushort = F.getParent()->	      <
      getOrInsertFunction("map2check_klee_ushort",	      <
            Type::getVoidTy(*this->Ctx),		      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
        Type::getInt32Ty(*this->Ctx),			      <
            Type::getInt8PtrTy(*this->Ctx),		      <
            NULL);					      <
							      <
  this->map2check_klee_char = F.getParent()->		      <
    getOrInsertFunction("map2check_klee_char",		      <
			Type::getVoidTy(*this->Ctx),	      <
      Type::getInt32Ty(*this->Ctx),			      <
      Type::getInt32Ty(*this->Ctx),			      <
      Type::getInt32Ty(*this->Ctx),			      <
          Type::getInt8PtrTy(*this->Ctx),		      <
          NULL);					      <
							      <
    this->map2check_klee_long = F.getParent()->		      <
    getOrInsertFunction("map2check_klee_long",		      <
			Type::getVoidTy(*this->Ctx),	      <
      Type::getInt32Ty(*this->Ctx),			      <
      Type::getInt32Ty(*this->Ctx),			      <
      Type::getInt32Ty(*this->Ctx),			      <
          Type::getInt8PtrTy(*this->Ctx),		      <
          NULL);					      <
							      <
							      <
  this->map2check_pointer = F.getParent()->			  this->map2check_pointer = F.getParent()->
    getOrInsertFunction("map2check_add_store_pointer",		    getOrInsertFunction("map2check_add_store_pointer",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
      Type::getInt8PtrTy(*this->Ctx),				      Type::getInt8PtrTy(*this->Ctx),
            NULL);						            NULL);

  this->map2check_check_deref = F.getParent()->			  this->map2check_check_deref = F.getParent()->
    getOrInsertFunction("map2check_check_deref",		    getOrInsertFunction("map2check_check_deref",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            NULL);						            NULL);

  this->map2check_malloc = F.getParent()->			  this->map2check_malloc = F.getParent()->
    getOrInsertFunction("map2check_malloc",			    getOrInsertFunction("map2check_malloc",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt64Ty(*this->Ctx),			            Type::getInt64Ty(*this->Ctx),
            NULL);						            NULL);

  this->map2check_posix = F.getParent()->			  this->map2check_posix = F.getParent()->
    getOrInsertFunction("map2check_posix",			    getOrInsertFunction("map2check_posix",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt64Ty(*this->Ctx),			            Type::getInt64Ty(*this->Ctx),
            NULL);						            NULL);
  this->map2check_calloc = F.getParent()->			  this->map2check_calloc = F.getParent()->
    getOrInsertFunction("map2check_calloc",			    getOrInsertFunction("map2check_calloc",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt64Ty(*this->Ctx),			            Type::getInt64Ty(*this->Ctx),
            Type::getInt64Ty(*this->Ctx),			            Type::getInt64Ty(*this->Ctx),
            NULL);						            NULL);

  this->map2check_alloca = F.getParent()->			  this->map2check_alloca = F.getParent()->
    getOrInsertFunction("map2check_alloca",			    getOrInsertFunction("map2check_alloca",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            NULL);						            NULL);

  this->map2check_non_static_alloca = F.getParent()->		  this->map2check_non_static_alloca = F.getParent()->
    getOrInsertFunction("map2check_non_static_alloca",		    getOrInsertFunction("map2check_non_static_alloca",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            NULL);						            NULL);

  this->map2check_function = F.getParent()->			  this->map2check_function = F.getParent()->
    getOrInsertFunction("map2check_function",			    getOrInsertFunction("map2check_function",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            NULL);						            NULL);

  this->map2check_free = F.getParent()->			  this->map2check_free = F.getParent()->
    getOrInsertFunction("map2check_free",			    getOrInsertFunction("map2check_free",
            Type::getVoidTy(*this->Ctx),			            Type::getVoidTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt32Ty(*this->Ctx),			            Type::getInt32Ty(*this->Ctx),
            Type::getInt8PtrTy(*this->Ctx),			            Type::getInt8PtrTy(*this->Ctx),
            NULL);						            NULL);

  this->map2check_success = F.getParent()->		      <
    getOrInsertFunction("map2check_success",		      <
            Type::getVoidTy(*this->Ctx),		      <
            NULL);					      <
}								}


void MemoryTrackPass::cleanWitnessInfoFile() {		      <
							      <
}							      <
							      <
void MemoryTrackPass::instrumentFunctionArgumentAddress() {	void MemoryTrackPass::instrumentFunctionArgumentAddress() {
    Function* F = this->currentFunction;			    Function* F = this->currentFunction;
    Module* M = this->currentFunction->getParent();		    Module* M = this->currentFunction->getParent();
    const DataLayout dataLayout = M->getDataLayout();		    const DataLayout dataLayout = M->getDataLayout();

    Function::iterator bb = this->currentFunction->begin();	    Function::iterator bb = this->currentFunction->begin();
    // // bb--;							    // // bb--;

    BasicBlock::iterator i = bb->begin();			    BasicBlock::iterator i = bb->begin();
    i++;							    i++;
//    i++;							//    i++;

							      >
    for(auto arg = F->arg_begin(); arg != F->arg_end(); arg++	    for(auto arg = F->arg_begin(); arg != F->arg_end(); arg++
        Argument* functionArg = &(*arg);			        Argument* functionArg = &(*arg);

//        functionArg->						//        functionArg->
        auto type = functionArg->getType();			        auto type = functionArg->getType();
        unsigned typeSize = dataLayout.getTypeSizeInBits(type	        unsigned typeSize = dataLayout.getTypeSizeInBits(type
        IRBuilder<> builder((Instruction*)i);			        IRBuilder<> builder((Instruction*)i);
        Value* name_llvm = builder.CreateGlobalStringPtr	        Value* name_llvm = builder.CreateGlobalStringPtr
          (functionArg->getName());				          (functionArg->getName());

        ConstantInt* typeSizeValue = ConstantInt::getSigned(T	        ConstantInt* typeSizeValue = ConstantInt::getSigned(T
        Value* argCast;						        Value* argCast;


        if(type->isPointerTy()) {				        if(type->isPointerTy()) {

            Twine mapcheck_bitcast_argument("mapcheck_bitcast	            Twine mapcheck_bitcast_argument("mapcheck_bitcast
            argCast = CastInst::CreatePointerCast(functionArg	            argCast = CastInst::CreatePointerCast(functionArg
                        Type::getInt8PtrTy(*this->Ctx),		                        Type::getInt8PtrTy(*this->Ctx),
                        mapcheck_bitcast_argument,		                        mapcheck_bitcast_argument,
                        (Instruction*) i);			                        (Instruction*) i);

        } else {						        } else {

            argCast = functionArg;				            argCast = functionArg;
        }							        }





//        ConstantInt* primitiveSizeValue = ConstantInt::getS	//        ConstantInt* primitiveSizeValue = ConstantInt::getS


        Value* args[] = {name_llvm, argCast, typeSizeValue, t	        Value* args[] = {name_llvm, argCast, typeSizeValue, t
        builder.CreateCall(map2check_alloca, args);		        builder.CreateCall(map2check_alloca, args);
    }								    }

}								}

bool MemoryTrackPass::runOnFunction(Function &F) {		bool MemoryTrackPass::runOnFunction(Function &F) {
    this->Ctx = &F.getContext();				    this->Ctx = &F.getContext();
    this->currentFunction = &F;					    this->currentFunction = &F;
    Module* currentModule = this->currentFunction->getParent(	    Module* currentModule = this->currentFunction->getParent(
    this->prepareMap2CheckInstructions();			    this->prepareMap2CheckInstructions();
							      >	    this->instrumentInit();

    if(F.getName() == "main") {					    if(F.getName() == "main") {
        //auto globalVars = currentModule->getGlobalList();	        //auto globalVars = currentModule->getGlobalList();
        this->functionsValues.push_back(this->currentFunction	        this->functionsValues.push_back(this->currentFunction
        this->mainFunctionInitialized = true;			        this->mainFunctionInitialized = true;
        this->mainFunction = &F;				        this->mainFunction = &F;
      this->instrumentInit();				      <
      this->instrumentReleaseMemory();			      <
    }								    }

    this->instrumentFunctionAddress();				    this->instrumentFunctionAddress();
							      <
//    this->instrumentFunctionArgumentAddress();	      <
   for (Function::iterator bb = F.begin(),			   for (Function::iterator bb = F.begin(),
      e = F.end(); bb != e; ++bb) {				      e = F.end(); bb != e; ++bb) {
      for (BasicBlock::iterator i = bb->begin(),		      for (BasicBlock::iterator i = bb->begin(),
         e = bb->end(); i != e; ++i) {				         e = bb->end(); i != e; ++i) {
          this->currentInstruction = i;				          this->currentInstruction = i;

          if (CallInst* callInst = dyn_cast<CallInst>(&*i)) {	          if (CallInst* callInst = dyn_cast<CallInst>(&*i)) {
              this->getDebugInfo();				              this->getDebugInfo();
              this->runOnCallInstruction();			              this->runOnCallInstruction();
          } else if (StoreInst* storeInst = dyn_cast<StoreIns	          } else if (StoreInst* storeInst = dyn_cast<StoreIns
              this->getDebugInfo();			      |	              this->getDebugInfo();	      
	      if(!this->isTrackingFunction)		      |	              this->runOnStoreInstruction();
		this->runOnStoreInstruction();		      <
          } else if (AllocaInst* allocainst = dyn_cast<Alloca	          } else if (AllocaInst* allocainst = dyn_cast<Alloca
              this->getDebugInfo();			      |	              this->getDebugInfo();	      
	      if(!this->isTrackingFunction)		      |	              this->runOnAllocaInstruction();
		this->runOnAllocaInstruction();		      |
              //this->runOnAllocaInstruction();		      <
          } else if(LoadInst* loadInst = dyn_cast<LoadInst>(&	          } else if(LoadInst* loadInst = dyn_cast<LoadInst>(&
              this->getDebugInfo();			      |	              this->getDebugInfo();	      
	      if(!this->isTrackingFunction)		      |	              this->runOnLoadInstruction();
		this->runOnLoadInstruction();		      <
          }							          }


      }								      }
   }								   }
   return true;							   return true;
}								}

char MemoryTrackPass::ID = 0;					char MemoryTrackPass::ID = 0;
static RegisterPass<MemoryTrackPass> X("memory_track", "Valid	static RegisterPass<MemoryTrackPass> X("memory_track", "Valid
